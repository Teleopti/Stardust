<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<configSections>
		<section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
		<sectionGroup name="dotNetOpenAuth" type="DotNetOpenAuth.Configuration.DotNetOpenAuthSection, DotNetOpenAuth.Core">
			<section name="messaging" type="DotNetOpenAuth.Configuration.MessagingElement, DotNetOpenAuth.Core" requirePermission="false" allowLocation="true" />
			<section name="reporting" type="DotNetOpenAuth.Configuration.ReportingElement, DotNetOpenAuth.Core" requirePermission="false" allowLocation="true" />
			<section name="openid" type="DotNetOpenAuth.Configuration.OpenIdElement, DotNetOpenAuth.OpenId" requirePermission="false" allowLocation="true" />
			<section name="oauth" type="DotNetOpenAuth.Configuration.OAuthElement, DotNetOpenAuth.OAuth" requirePermission="false" allowLocation="true" />
		</sectionGroup>
		<sectionGroup name="authBridge" type="AuthBridge.Configuration.AuthBridgeSectionGroup, AuthBridge, Version=1.0.0.12, Culture=neutral">
			<section name="multiProtocolIssuer" type="AuthBridge.Configuration.MultiProtocolIssuerSection, AuthBridge, Version=1.0.0.12, Culture=neutral" />
		</sectionGroup>
		<section name="microsoft.identityModel" type="Microsoft.IdentityModel.Configuration.MicrosoftIdentityModelSection, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
		<section name="unity" type="Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Microsoft.Practices.Unity.Configuration" />
	</configSections>
	<appSettings>
		<add key="aspnet:UseHostHeaderForRequestUrl" value="true" />
		<add key="UseRelativeConfiguration" value="$(WEB_DEPLOY)" />
		<add key="CustomEndpointHost" value="$(DNS_ALIAS)" />
	</appSettings>
	<runtime>
		<!-- This prevents the Windows Event Log from frequently logging that HMAC1 is being used (when the other party needs it). -->
		<legacyHMACWarning enabled="0" />
		<!-- When targeting ASP.NET MVC 3, this assemblyBinding makes MVC 1 and 2 references relink
		     to MVC 3 so libraries such as DotNetOpenAuth that compile against MVC 1 will work with it.
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
			</dependentAssembly>
		</assemblyBinding>
		 -->
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
				<bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="log4net" publicKeyToken="669e0ddf0bb1aa2a" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-1.2.15.0" newVersion="1.2.15.0" />
			</dependentAssembly>
		</assemblyBinding>
	</runtime>

	<log4net>
		<root>
			<appender-ref ref="RollingFileAppender" />
			<level value="ERROR" />
		</root>
		<!-- <logger name="DotNetOpenAuth.OpenId">
			<level value="ALL" />
		</logger>
		<logger name="AuthBridge.Protocols.OpenID">
			<level value="ALL" />
		</logger> -->
		<appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
			<file value="..\..\Logs\WebAuthApps.log" />
			<appendToFile value="true" />
			<rollingStyle value="Size" />
			<maxSizeRollBackups value="10" />
			<maximumFileSize value="100KB" />
			<staticLogFileName value="true" />
			<layout type="log4net.Layout.PatternLayout">
				<conversionPattern value="%date [%thread] %-5level %logger [%property{NDC}] - %message%newline" />
			</layout>
		</appender>
	</log4net>

	<system.net>
		<defaultProxy enabled="true" />
		<settings>
			<!-- This setting causes .NET to check certificate revocation lists (CRL) 
			     before trusting HTTPS certificates.  But this setting tends to not 
			     be allowed in shared hosting environments. -->
			<!--<servicePointManager checkCertificateRevocationList="true"/>-->
		</settings>
	</system.net>
	<dotNetOpenAuth>

		<!-- Allow DotNetOpenAuth to publish usage statistics to library authors to improve the library. -->
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
		<openid>
			<relyingParty>
				<security requireSsl="false">
					<!-- Uncomment the trustedProviders tag if your relying party should only accept positive assertions from a closed set of OpenID Providers. -->
					<!--<trustedProviders rejectAssertionsFromUntrustedProviders="true">
						<add endpoint="https://www.google.com/accounts/o8/ud" />
					</trustedProviders>-->
				</security>
				<behaviors>
					<!-- The following OPTIONAL behavior allows RPs to use SREG only, but be compatible
					     with OPs that use Attribute Exchange (in various formats). -->
					<add type="DotNetOpenAuth.OpenId.RelyingParty.Behaviors.AXFetchAsSregTransform, DotNetOpenAuth.OpenId.RelyingParty" />
				</behaviors>
			</relyingParty>
			<provider>
			</provider>
		</openid>
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
		<messaging>
			<untrustedWebRequest timeout="00:00:30" readWriteTimeout="00:00:10">
				<whitelistHosts>
					<add name="localhost" />
					<add name="$(HOST_NAME)" />
				</whitelistHosts>
			</untrustedWebRequest>
		</messaging>
		<reporting enabled="false" />
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
	</dotNetOpenAuth>
	<uri>
		<!-- The uri section is necessary to turn on .NET 3.5 support for IDN (international domain names),
		     which is necessary for OpenID urls with unicode characters in the domain/host name.
		     It is also required to put the Uri class into RFC 3986 escaping mode, which OpenID and OAuth require. -->
		<idn enabled="All" />
		<iriParsing enabled="true" />
	</uri>
	<authBridge>
		<multiProtocolIssuer identifier="$(UrlAuthenticationBridge)" responseEndpoint="$(UrlAuthenticationBridge)response">
			<signingCertificateFile pfxFilePath="test-certificate.pfx" password="Passw0rd!" />
			<claimProviders>
				$(WindowsClaimProvider)
				$(TeleoptiClaimProvider)
				
				<!-- custom section starts here -->
				<!--<add identifier="urn:SalesForce" url="https://notused" protocolHandler="SalesForceHandler">
					<params>
						<add key="wll_appid" value="appid" />
						<add key="wll_secret" value="appsecret" />
					</params>
				</add>-->
				<!-- custom section ends here -->
			</claimProviders>
			<scopes>
				<scope uri="$(URL)" identifier="http://default-with-policyengine/" useClaimsPolicyEngine="true" />
				<scope uri="$(URL)" identifier="http://default-without-policyengine/" useClaimsPolicyEngine="false" />
			</scopes>
		</multiProtocolIssuer>
	</authBridge>
	<microsoft.identityModel>
		<service>
			<federatedAuthentication>
				<wsFederation passiveRedirectEnabled="false" issuer="$(UrlAuthenticationBridge)" realm="http://default-with-policyengine/" requireHttps="false" signOutReply="$(URL)" />
				<cookieHandler requireSsl="false" hideFromScript="true" />
			</federatedAuthentication>
		</service>
	</microsoft.identityModel>
	<system.web>
		<customErrors mode="On" />
		<httpRuntime requestValidationMode="2.0" requestValidationType="AuthBridge.Web.AllowTokenPostRequestValidator" enableVersionHeader="false" />
		<compilation targetFramework="4.5">
			<assemblies>
				<add assembly="System.Web.Mvc, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
				<add assembly="System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
				<add assembly="System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
				<add assembly="System.Data.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089" />
			</assemblies>
		</compilation>
		<authentication mode="None" />
		<authorization>
			<allow users="*" />
		</authorization>
		<httpCookies httpOnlyCookies="true" />
		<sessionState mode="Off"></sessionState>
		<!--$(MachineKey)-->
		<pages controlRenderingCompatibilityVersion="3.5" clientIDMode="AutoID" pageParserFilterType="System.Web.Mvc.ViewTypeParserFilter, System.Web.Mvc, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35"
         pageBaseType="System.Web.Mvc.ViewPage, System.Web.Mvc, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35"
         userControlBaseType="System.Web.Mvc.ViewUserControl, System.Web.Mvc, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35">
			<namespaces>
				<add namespace="System.Web.Mvc" />
				<add namespace="System.Web.Mvc.Ajax" />
				<add namespace="System.Web.Mvc.Html" />
				<add namespace="System.Web.Routing" />
				<add namespace="System.Linq" />
				<add namespace="System.Collections.Generic" />
			</namespaces>
		</pages>
		<httpModules>
			<add name="Log4NetModule" type="Teleopti.Ccc.Web.AuthenticationBridge.Controllers.Log4NetModule, Teleopti.Ccc.Web.AuthenticationBridge, Culture=neutral"/>
			<add name="WSFederationAuthenticationModule" type="Microsoft.IdentityModel.Web.WSFederationAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
			<add name="SessionAuthenticationModule" type="Microsoft.IdentityModel.Web.SessionAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
		</httpModules>
	</system.web>
	<location path="Content">
		<system.web>
			<authorization>
				<allow users="*" />
			</authorization>
		</system.web>
	</location>
	<system.web.extensions />
	<system.webServer>
		<validation validateIntegratedModeConfiguration="false" />
		<modules runAllManagedModulesForAllRequests="true">
			<add name="Log4NetModule" type="Teleopti.Ccc.Web.AuthenticationBridge.Controllers.Log4NetModule, Teleopti.Ccc.Web.AuthenticationBridge, Culture=neutral" preCondition="managedHandler"/>
			<add name="WSFederationAuthenticationModule" type="Microsoft.IdentityModel.Web.WSFederationAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
			<add name="SessionAuthenticationModule" type="Microsoft.IdentityModel.Web.SessionAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
		</modules>
    <httpProtocol>
      <customHeaders>
        <clear />
        <remove name="Server" />
        <remove name="X-Powered-By" />
      </customHeaders>
    </httpProtocol>
	</system.webServer>
	<unity xmlns="http://schemas.microsoft.com/practices/2010/unity">
		<container>
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.GoogleHandler, AuthBridge" name="GoogleHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.OpenIdHandler, AuthBridge" name="OpenIdHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.RelativeOpenIdHandler, AuthBridge" name="RelativeOpenIdHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.YahooHandler, AuthBridge" name="YahooHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.LiveIdHandler, AuthBridge" name="LiveIdHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.AzureAdOAuthHandler, AuthBridge" name="AzureAdOAuthHandler"/>
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.FacebookHandler, AuthBridge" name="FacebookHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.TwitterHandler, AuthBridge" name="TwitterHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.WSFed.WSFedHandler, AuthBridge" name="WSFedHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.WSFed.WindowsAzureADHandler, AuthBridge" name="WindowsAzureADHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.Saml.SamlHandler, AuthBridge" name="SamlHandler"/>
			<!-- custom section starts here -->
			<!-- <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="SalesForceSignIn.SalesForceHandler, SalesForceSignIn" name="SalesForceHandler" /> -->
			<!-- custom section ends here -->
		</container>
	</unity>
</configuration>