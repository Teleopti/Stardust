<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<configSections>
		<section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
		<sectionGroup name="dotNetOpenAuth" type="DotNetOpenAuth.Configuration.DotNetOpenAuthSection, DotNetOpenAuth.Core">
			<section name="messaging" type="DotNetOpenAuth.Configuration.MessagingElement, DotNetOpenAuth.Core" requirePermission="false" allowLocation="true" />
			<section name="reporting" type="DotNetOpenAuth.Configuration.ReportingElement, DotNetOpenAuth.Core" requirePermission="false" allowLocation="true" />
			<section name="openid" type="DotNetOpenAuth.Configuration.OpenIdElement, DotNetOpenAuth.OpenId" requirePermission="false" allowLocation="true" />
			<section name="oauth" type="DotNetOpenAuth.Configuration.OAuthElement, DotNetOpenAuth.OAuth" requirePermission="false" allowLocation="true" />
		</sectionGroup>
		<sectionGroup name="authBridge" type="AuthBridge.Configuration.AuthBridgeSectionGroup, AuthBridge, Version=1.0.0.12, Culture=neutral">
			<section name="multiProtocolIssuer" type="AuthBridge.Configuration.MultiProtocolIssuerSection, AuthBridge, Version=1.0.0.12, Culture=neutral" />
		</sectionGroup>
		<section name="system.identityModel" type="System.IdentityModel.Configuration.SystemIdentityModelSection, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>
		<section name="system.identityModel.services" type="System.IdentityModel.Services.Configuration.SystemIdentityModelServicesSection, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>
		<section name="unity" type="Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Microsoft.Practices.Unity.Configuration" />
	</configSections>
	<appSettings>
		<add key="aspnet:UseHostHeaderForRequestUrl" value="true" />
		<add key="UseRelativeConfiguration" value="$(WEB_DEPLOY)" />
		<add key="CustomEndpointHost" value="$(DNS_ALIAS)" />
		<add key="checkSignature" value="true" />
	</appSettings>
	<runtime>
		<!-- This prevents the Windows Event Log from frequently logging that HMAC1 is being used (when the other party needs it). -->
		<legacyHMACWarning enabled="0" />
		<!-- When targeting ASP.NET MVC 3, this assemblyBinding makes MVC 1 and 2 references relink
			 to MVC 3 so libraries such as DotNetOpenAuth that compile against MVC 1 will work with it.
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
			</dependentAssembly>
		</assemblyBinding>
		 -->
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
				<bindingRedirect oldVersion="0.0.0.0-11.0.0.0" newVersion="11.0.0.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="log4net" publicKeyToken="669e0ddf0bb1aa2a" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-1.2.15.0" newVersion="1.2.15.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Helpers" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Web.WebPages" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="0.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="Microsoft.ApplicationInsights" culture="neutral" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="0.0.0.0-2.4.0.0" newVersion="2.4.0.0" />
			</dependentAssembly>
		</assemblyBinding>
	</runtime>

	<log4net>
		<root>
			<appender-ref ref="EventLogAppender" />
			<appender-ref ref="RollingFileAppender" />
			<appender-ref ref="aiAppender" />
			<level value="ERROR" />
		</root>
		<!-- <logger name="DotNetOpenAuth.OpenId">
			<level value="ALL" />
		</logger>
		<logger name="AuthBridge.Protocols.OpenID">
			<level value="ALL" />
		</logger> -->
		<appender name="EventLogAppender" type="log4net.Appender.EventLogAppender">
			<applicationName value="TeleoptiWebAuthApps" />
			<layout type="log4net.Layout.PatternLayout">
				<conversionPattern value="%date [%thread] %-5level %logger [%property{NDC}] - %message%newline" />
			</layout>
		</appender>
		<appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
			<file value="..\..\Logs\WebAuthApps.log" />
			<appendToFile value="true" />
			<rollingStyle value="Size" />
			<maxSizeRollBackups value="10" />
			<maximumFileSize value="100KB" />
			<staticLogFileName value="true" />
			<layout type="log4net.Layout.PatternLayout">
				<conversionPattern value="%date [%thread] %-5level %logger [%property{NDC}] - %message%newline" />
			</layout>
		</appender>
		<appender name="aiAppender" type="Microsoft.ApplicationInsights.Log4NetAppender.ApplicationInsightsAppender, Microsoft.ApplicationInsights.Log4NetAppender">
			<layout type="log4net.Layout.PatternLayout">
				<conversionPattern value="%message%newline" />
			</layout>
		</appender>
	</log4net>

	<system.net>
		<defaultProxy enabled="true" />
		<settings>
			<!-- This setting causes .NET to check certificate revocation lists (CRL) 
				 before trusting HTTPS certificates.  But this setting tends to not 
				 be allowed in shared hosting environments. -->
			<!--<servicePointManager checkCertificateRevocationList="true"/>-->
		</settings>
	</system.net>
	<dotNetOpenAuth>

		<!-- Allow DotNetOpenAuth to publish usage statistics to library authors to improve the library. -->
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
		<openid>
			<relyingParty>
				<security requireSsl="$(HTTPSGETENABLED)">
					<!-- Uncomment the trustedProviders tag if your relying party should only accept positive assertions from a closed set of OpenID Providers. -->
					<trustedProviders rejectAssertionsFromUntrustedProviders="true">
						<add endpoint="$(URL)SSO/OpenId/Provider" />
						<add endpoint="$(URL_WINDOWS_IDENTITY_PROVIDER)OpenId/Provider" />
						<!--OtherTrustedOpenIdProvider-->
					</trustedProviders>
				</security>
				<behaviors>
					<!-- The following OPTIONAL behavior allows RPs to use SREG only, but be compatible
						 with OPs that use Attribute Exchange (in various formats). -->
					<add type="DotNetOpenAuth.OpenId.RelyingParty.Behaviors.AXFetchAsSregTransform, DotNetOpenAuth.OpenId.RelyingParty" />
				</behaviors>
			</relyingParty>
			<provider>
			</provider>
		</openid>
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
		<messaging>
			<untrustedWebRequest timeout="00:00:45" readWriteTimeout="00:00:10">
				<whitelistHosts>
					<add name="localhost" />
					<add name="$(HOST_NAME)" />
				</whitelistHosts>
			</untrustedWebRequest>
		</messaging>
		<reporting enabled="false" />
		<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. -->
		<!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ -->
	</dotNetOpenAuth>
	<uri>
		<!-- The uri section is necessary to turn on .NET 3.5 support for IDN (international domain names),
			 which is necessary for OpenID urls with unicode characters in the domain/host name.
			 It is also required to put the Uri class into RFC 3986 escaping mode, which OpenID and OAuth require. -->
		<idn enabled="All" />
		<iriParsing enabled="true" />
	</uri>
	<authBridge>
		<multiProtocolIssuer identifier="$(UrlAuthenticationBridge)" responseEndpoint="$(UrlAuthenticationBridge)response">
			<signingCertificateFile pfxFilePath="teleopti.auth.pfx" password="Passw0rd!" />
			<claimProviders>
				$(WindowsClaimProvider)
				$(TeleoptiClaimProvider)

				<!-- custom section starts here -->
				<!--<add identifier="urn:SalesForce" url="https://notused" protocolHandler="SalesForceHandler">
					<params>
						<add key="wll_appid" value="appid" />
						<add key="wll_secret" value="appsecret" />
					</params>
				</add>-->
				<!-- custom section ends here -->
			</claimProviders>
			<scopes>
				<scope uri="$(URL)Start/Return/HandleReturn" identifier="http://sample-with-policyengine/" useClaimsPolicyEngine="true" useRelativeUri="$(WEB_DEPLOY)" />
				<scope uri="$(URL)Start/Return/HandleReturn" identifier="http://sample-without-policyengine/" useClaimsPolicyEngine="false" useRelativeUri="$(WEB_DEPLOY)" />
				<scope uri="$(UrlAuthenticationBridge)botforward.aspx" identifier="http://grant-bot/" useClaimsPolicyEngine="false" useRelativeUri="$(WEB_DEPLOY)" />
				<scope uri="http://localhost:3979/Callback" identifier="http://grantbot-dev/" useClaimsPolicyEngine="false" useRelativeUri="false" />
			</scopes>
		</multiProtocolIssuer>
	</authBridge>
	<system.identityModel.services>
		<federationConfiguration>
			<wsFederation passiveRedirectEnabled="false" issuer="$(UrlAuthenticationBridge)" realm="http://sample-with-policyengine/" requireHttps="$(HTTPSGETENABLED)" signOutReply="$(URL)" />
			<cookieHandler requireSsl="$(HTTPSGETENABLED)" hideFromScript="true" />
		</federationConfiguration>
	</system.identityModel.services>
	<system.web>
		<customErrors mode="On" />
		<httpRuntime targetFramework="4.7.2" requestValidationMode="2.0" requestValidationType="AuthBridge.Web.AllowTokenPostRequestValidator" enableVersionHeader="false" />
		<compilation targetFramework="4.7.2">
			<assemblies>
				<add assembly="System.Web.Mvc, Version=5.2.3.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
				<add assembly="System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
				<add assembly="System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
				<add assembly="System.Data.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089" />
			</assemblies>
		</compilation>
		<authentication mode="None" >
			<forms requireSSL="$(HTTPSGETENABLED)"></forms>
		</authentication>
		<authorization>
			<allow users="*" />
		</authorization>
		<httpCookies httpOnlyCookies="true" />
		<sessionState mode="Off"></sessionState>
		<pages controlRenderingCompatibilityVersion="3.5" clientIDMode="AutoID" pageParserFilterType="System.Web.Mvc.ViewTypeParserFilter, System.Web.Mvc, Version=5.2.3.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35"
		 pageBaseType="System.Web.Mvc.ViewPage, System.Web.Mvc, Version=5.2.3.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35"
		 userControlBaseType="System.Web.Mvc.ViewUserControl, System.Web.Mvc, Version=5.2.3.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35">
			<namespaces>
				<add namespace="System.Web.Mvc" />
				<add namespace="System.Web.Mvc.Ajax" />
				<add namespace="System.Web.Mvc.Html" />
				<add namespace="System.Web.Routing" />
				<add namespace="System.Linq" />
				<add namespace="System.Collections.Generic" />
			</namespaces>
		</pages>
		<httpModules>
			<add name="Log4NetModule" type="Teleopti.Ccc.Web.AuthenticationBridge.Controllers.Log4NetModule, Teleopti.Ccc.Web.AuthenticationBridge, Culture=neutral"/>
			<add name="WSFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
			<add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
			<add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
		</httpModules>
		<machineKey validationKey="$(machineKey.validationKey)" decryptionKey="$(machineKey.decryptionKey)" decryption="AES" validation="SHA1" />
	</system.web>
	<location path="Content">
		<system.web>
			<authorization>
				<allow users="*" />
			</authorization>
		</system.web>
	</location>
	<system.web.extensions />
	<system.webServer>
		<validation validateIntegratedModeConfiguration="false" />
		<modules runAllManagedModulesForAllRequests="false">
			<add name="Log4NetModule" type="Teleopti.Ccc.Web.AuthenticationBridge.Controllers.Log4NetModule, Teleopti.Ccc.Web.AuthenticationBridge, Culture=neutral" preCondition="managedHandler"/>
			<add name="WSFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
			<add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
			<remove name="TelemetryCorrelationHttpModule" />
			<add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="integratedMode,managedHandler" />
			<remove name="ApplicationInsightsWebTracking" />
			<add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
		</modules>
		<handlers>
			<remove name="WebDAV" />
			<remove name="ExtensionlessUrlHandler-Integrated-4.0" />
			<remove name="OPTIONSVerbHandler" />
			<remove name="TRACEVerbHandler" />
			<add name="ExtensionlessUrlHandler-Integrated-4.0" path="*." verb="GET,HEAD,POST,DEBUG,DELETE,PUT" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
			<add name="FederationMetadata-Integrated-4.0" path="*FederationMetadata.xml" verb="GET" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
		</handlers>
		<httpProtocol>
			<customHeaders>
				<clear />
				<remove name="Server" />
				<remove name="X-Powered-By" />
				<add name="Content-Security-Policy" value="script-src 'self' 'unsafe-inline' 'unsafe-eval'; frame-ancestors 'self' $(CSP_PARENT_URL);" />
				<add name="Referrer-Policy" value="strict-origin-when-cross-origin" />
				<add name="X-Content-Type-Options" value="nosniff" />
				<add name="X-XSS-Protection" value="1; mode=block" />
				<add name="Cache-Control" value="no-cache, no-store" />
				<add name="Expires" value="-1" />
				$(HSTS_HEADER)
			</customHeaders>
		</httpProtocol>
	</system.webServer>
	<unity xmlns="http://schemas.microsoft.com/practices/2010/unity">
		<container>
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.GoogleHandler, AuthBridge" name="GoogleHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.OpenIdHandler, AuthBridge" name="OpenIdHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.RelativeOpenIdHandler, AuthBridge" name="RelativeOpenIdHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.YahooHandler, AuthBridge" name="YahooHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.LiveIdHandler, AuthBridge" name="LiveIdHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.AzureAdOAuthHandler, AuthBridge" name="AzureAdOAuthHandler"/>
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.FacebookHandler, AuthBridge" name="FacebookHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.TwitterHandler, AuthBridge" name="TwitterHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.WSFed.WSFedHandler, AuthBridge" name="WSFedHandler">
				<lifetime type="singleton" />
			</register>
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.WSFed.WindowsAzureADHandler, AuthBridge" name="WindowsAzureADHandler" />
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.Saml.SamlHandler, AuthBridge" name="SamlHandler">
				<lifetime type="singleton" />
			</register>
			<register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.AWFOS.AWFOSHandler, AuthBridge" name="AWFOSHandler" />
			<!-- custom section starts here -->
			<!-- <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="SalesForceSignIn.SalesForceHandler, SalesForceSignIn" name="SalesForceHandler" /> -->
			<!-- custom section ends here -->
			<register type="AuthBridge.Configuration.IConfigurationRepository, AuthBridge" mapTo="Teleopti.Ccc.Web.AuthenticationBridge.Configuration.TeleoptiConfigurationRepository, Teleopti.Ccc.Web.AuthenticationBridge">
				<lifetime type="singleton" />
			</register>
		</container>
	</unity>
</configuration>