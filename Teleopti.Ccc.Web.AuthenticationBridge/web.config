<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
	  <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
		<sectionGroup name="dotNetOpenAuth" type="DotNetOpenAuth.Configuration.DotNetOpenAuthSection, DotNetOpenAuth.Core">
			<section name="messaging" type="DotNetOpenAuth.Configuration.MessagingElement, DotNetOpenAuth.Core" requirePermission="false" allowLocation="true" />
			<section name="reporting" type="DotNetOpenAuth.Configuration.ReportingElement, DotNetOpenAuth.Core" requirePermission="false" allowLocation="true" />
		<section name="openid" type="DotNetOpenAuth.Configuration.OpenIdElement, DotNetOpenAuth.OpenId" requirePermission="false" allowLocation="true" /><section name="oauth" type="DotNetOpenAuth.Configuration.OAuthElement, DotNetOpenAuth.OAuth" requirePermission="false" allowLocation="true" /></sectionGroup>
	<sectionGroup name="authBridge" type="AuthBridge.Configuration.AuthBridgeSectionGroup, AuthBridge, Version=1.0.0.0, Culture=neutral">
      <section name="multiProtocolIssuer" type="AuthBridge.Configuration.MultiProtocolIssuerSection, AuthBridge, Version=1.0.0.0, Culture=neutral" />
    </sectionGroup><section name="microsoft.identityModel" type="Microsoft.IdentityModel.Configuration.MicrosoftIdentityModelSection, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><section name="unity" type="Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Microsoft.Practices.Unity.Configuration" /></configSections>

	<runtime>

		<!-- This prevents the Windows Event Log from frequently logging that HMAC1 is being used (when the other party needs it). -->
		<legacyHMACWarning enabled="0" />
		<!-- When targeting ASP.NET MVC 3, this assemblyBinding makes MVC 1 and 2 references relink
		     to MVC 3 so libraries such as DotNetOpenAuth that compile against MVC 1 will work with it.
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
			</dependentAssembly>
		</assemblyBinding>
		 -->
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
			</dependentAssembly>
		</assemblyBinding>
	</runtime>

	<log4net>
		<root>
			<appender-ref ref="RollingFileAppender" />
			<level value="ERROR" />
		</root>
		<logger name="DotNetOpenAuth.OpenId">
			<level value="ALL" />
		</logger>
		<logger name="AuthBridge.Protocols.OpenID">
			<level value="ALL" />
		</logger>
		<appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
			<file value="c:\temp\WebAuthApps.log" />
			<appendToFile value="true" />
			<rollingStyle value="Size" />
			<maxSizeRollBackups value="10" />
			<maximumFileSize value="100KB" />
			<staticLogFileName value="true" />
			<layout type="log4net.Layout.PatternLayout">
				<conversionPattern value="%date [%thread] %-5level %logger [%property{NDC}] - %message%newline" />
			</layout>
		</appender>
	</log4net>
  
<system.net>
		<defaultProxy enabled="true" />
		<settings>
			<!-- This setting causes .NET to check certificate revocation lists (CRL) 
			     before trusting HTTPS certificates.  But this setting tends to not 
			     be allowed in shared hosting environments. -->
			<!--<servicePointManager checkCertificateRevocationList="true"/>-->
		</settings>
	</system.net><dotNetOpenAuth>
		
		<!-- Allow DotNetOpenAuth to publish usage statistics to library authors to improve the library. -->
	<!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. --><!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ --><openid>
		<relyingParty>
				<security requireSsl="false">
					<!-- Uncomment the trustedProviders tag if your relying party should only accept positive assertions from a closed set of OpenID Providers. -->
					<!--<trustedProviders rejectAssertionsFromUntrustedProviders="true">
						<add endpoint="https://www.google.com/accounts/o8/ud" />
					</trustedProviders>-->
				</security>
				<behaviors>
					<!-- The following OPTIONAL behavior allows RPs to use SREG only, but be compatible
					     with OPs that use Attribute Exchange (in various formats). -->
					<add type="DotNetOpenAuth.OpenId.RelyingParty.Behaviors.AXFetchAsSregTransform, DotNetOpenAuth.OpenId.RelyingParty" />
				</behaviors>
			</relyingParty><provider>
			</provider></openid><!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. --><!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ --><!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. --><!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ --><messaging>
      <untrustedWebRequest>
        <whitelistHosts>
          <!-- since this is a sample, and will often be used with localhost -->
          <add name="localhost" />
          <add name="teleopti745" />
        </whitelistHosts>
      </untrustedWebRequest>
    </messaging><reporting enabled="false" /><!-- This is an optional configuration section where aspects of dotnetopenauth can be customized. --><!-- For a complete set of configuration options see http://www.dotnetopenauth.net/developers/code-snippets/configuration-options/ --></dotNetOpenAuth><uri>
		<!-- The uri section is necessary to turn on .NET 3.5 support for IDN (international domain names),
		     which is necessary for OpenID urls with unicode characters in the domain/host name.
		     It is also required to put the Uri class into RFC 3986 escaping mode, which OpenID and OAuth require. -->
		<idn enabled="All" />
		<iriParsing enabled="true" />
	</uri>
	<authBridge>
		<multiProtocolIssuer identifier="$(UrlAuthenticationBridge)" responseEndpoint="$(UrlAuthenticationBridge)response">
			<!--<multiProtocolIssuer identifier="http://identity.bridge.com/" responseEndpoint="http://identity.bridge.com/response">-->
			<signingCertificateFile pfxFilePath="test-certificate.pfx" password="Passw0rd!" />
			<claimProviders>
				<add identifier="urn:Yahoo" url="http://notused/" protocolHandler="YahooHandler" />
				<add identifier="urn:Google" url="http://notused/" protocolHandler="GoogleHandler" />
				<add identifier="urn:Teleopti" url="$(UrlWindowsIdentityProvider)" protocolHandler="TeleoptiHandler" />
				<add identifier="urn:MyOpenId" url="http://notused/" protocolHandler="MyOpenIdHandler" />
				<add identifier="urn:LiveId" url="https://notused" protocolHandler="LiveIdHandler">
					<params>
						<add key="wll_appid" value="00000000480CA261" />
						<add key="wll_secret" value="JGnDMshOmEH90XmGlOzfvhkITydk-jVx" />
					</params>
				</add>
				<add identifier="urn:SalesForce" url="https://notused" protocolHandler="SalesForceHandler">
					<params>
						<add key="wll_appid" value="appid" />
						<add key="wll_secret" value="appsecret" />
					</params>
				</add>
				<add identifier="urn:Facebook" url="https://notused" protocolHandler="FacebookHandler">
					<params>
						<add key="application_id" value="173673902765073" />
						<add key="secret" value="65773b1c3b1c00e2c672be080ff54615" />
					</params>
				</add>
				<add identifier="urn:Twitter" url="http://notused/" protocolHandler="TwitterHandler">
					<params>
						<add key="api_url" value="http://twitter.com" />
						<add key="consumer_key" value="fQq1IP0IY3UHGArFyBpkg" />
						<add key="consumer_secret" value="uQcwznNpDJJNMh4mAJiVxpOM6nTvWRPd3cH971Ot4GA" />
					</params>
				</add>
				<add identifier="urn:IdentityServer" url="https://identityprovider.apphb.com/issue/wsfed" protocolHandler="WSFedHandler">
					<params>
						<add key="signingKeyThumbprint" value="cf50166ce4b901e38928cf56f820c4da668f96bf" />
					</params>
				</add>
				<add identifier="urn:office365:auth10preview" url="https://accounts.accesscontrol.windows.net/v2/wsfederation" protocolHandler="WindowsAzureADHandler">
					<params>
						<add key="signingKeyThumbprint" value="3464C5BDD2BE7F2B6112E2F08E9C0024E33D9FE0" />
						<add key="tenantId" value="a37242fd-30a6-4836-9c49-2049e46a471c" />
						<add key="appPrincipalId" value="1829c758-2bef-43df-a685-717089474509" />
						<add key="realmFormat" value="spn:{appPrincipalId}@{tenantId}" />
					</params>
				</add>
			</claimProviders>
			<scopes>
				<scope uri="$(Url)" identifier="http://sample-with-policyengine/" useClaimsPolicyEngine="true" />
				<scope uri="$(Url)" identifier="http://sample-without-policyengine/" useClaimsPolicyEngine="false" />
			</scopes>
		</multiProtocolIssuer>
	</authBridge><location path="Content">
    <system.web>
      <authorization>
        <allow users="*" />
      </authorization>
    </system.web>
  </location><system.web>
    <customErrors mode="Off" />
    <httpRuntime requestValidationMode="2.0" requestValidationType="AuthBridge.Web.AllowTokenPostRequestValidator" />
    <compilation debug="true" targetFramework="4.0">
      <assemblies>
        <add assembly="System.Web.Mvc, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
        <add assembly="System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
        <add assembly="System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
        <add assembly="System.Data.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089" />
      </assemblies>
    </compilation>
    <authentication mode="None" />
    <authorization>
      <allow users="*" />
    </authorization>
    <pages controlRenderingCompatibilityVersion="3.5" clientIDMode="AutoID">
      <namespaces>
        <add namespace="System.Web.Mvc" />
        <add namespace="System.Web.Mvc.Ajax" />
        <add namespace="System.Web.Mvc.Html" />
        <add namespace="System.Web.Routing" />
        <add namespace="System.Linq" />
        <add namespace="System.Collections.Generic" />
      </namespaces>
    </pages>
    <httpModules>
		<add name="Log4NetModule" type="Teleopti.Ccc.Web.AuthenticationBridge.Controllers.Log4NetModule, Teleopti.Ccc.Web.AuthenticationBridge, Version=1.0.0.0, Culture=neutral"/>
      <add name="WSFederationAuthenticationModule" type="Microsoft.IdentityModel.Web.WSFederationAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
      <add name="SessionAuthenticationModule" type="Microsoft.IdentityModel.Web.SessionAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
    </httpModules>
  </system.web><system.web.extensions /><system.webServer>
    <validation validateIntegratedModeConfiguration="false" />
    <modules runAllManagedModulesForAllRequests="true">
		<add name="Log4NetModule" type="Teleopti.Ccc.Web.AuthenticationBridge.Controllers.Log4NetModule, Teleopti.Ccc.Web.AuthenticationBridge, Version=1.0.0.0, Culture=neutral" preCondition="managedHandler"/>
      <add name="WSFederationAuthenticationModule" type="Microsoft.IdentityModel.Web.WSFederationAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
      <add name="SessionAuthenticationModule" type="Microsoft.IdentityModel.Web.SessionAuthenticationModule, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
    </modules>
  </system.webServer><unity xmlns="http://schemas.microsoft.com/practices/2010/unity">
    <container>
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.GoogleHandler, AuthBridge" name="GoogleHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.TeleoptiHandler, AuthBridge" name="TeleoptiHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.MyOpenIdHandler, AuthBridge" name="MyOpenIdHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OpenID.YahooHandler, AuthBridge" name="YahooHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.LiveIdHandler, AuthBridge" name="LiveIdHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.SalesForceHandler, AuthBridge" name="SalesForceHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.FacebookHandler, AuthBridge" name="FacebookHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.OAuth.TwitterHandler, AuthBridge" name="TwitterHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.WSFed.WSFedHandler, AuthBridge" name="WSFedHandler" />
      <register type="AuthBridge.Protocols.IProtocolHandler, AuthBridge" mapTo="AuthBridge.Protocols.WSFed.WindowsAzureADHandler, AuthBridge" name="WindowsAzureADHandler" />
    </container>
  </unity></configuration>